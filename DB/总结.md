### 三大范式
 	
[链接](https://www.cnblogs.com/mr-wuxiansheng/p/6910754.html)

- 第一范式：  
	又称1NF，它指的是在一个应用中的数据都可以组织成由行和列的表格形式，且表格的任意一个行列交叉点即单元格，都不可再划分为行和列的形式，实际上任意一张表格都满足1NF；  
	
- 第二范式：  
	又称2NF，它指的是在满足1NF的基础上，一张数据表中的任何非主键字段都全部依赖于主键字段，  
	没有任何非主键字段只依赖于主键字段的一部分。    
	即，可以由主键字段来唯一的确定一条记录。    
	比如学号+课程号的联合主键，可以唯一的确定某个成绩是哪个学员的哪门课的成绩，缺少学号或者缺少课程号，都不能确定成绩的意义。    
	
- 第三范式：  
	又称3NF，它是指在满足2NF的基础上，数据表的任何非主键字段之间都不产生函数依赖，  
	即非主键字段之间没有依赖关系，全部只依赖于主键字段。  
	例如将学员姓名和所属班级名称放在同一张表中是不科学的，因为学员依赖于班级，  
	可将学员信息和班级信息单独存放，以满足3NF。  

### join与left join的区别：
- inner join(等值连接) 只返回两个表中联结字段相等的行
- left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录
- right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录
			
### 数据库引擎

### 查询优化

### 其他积累
分库分表

- 主从复制，读写分离  
	对主库修改数据，查询使用从库。一主多从，来降低数据库读取压力。  
	数据库的主从复制能解决访问问题，并不能解决大规模的并发写入问题，要解决这个问题就要考虑mysql数据切分了 分库分表  

- 分库分表  
	根据实体业务来分库，分表。如，根据数据的活跃性，根据用户uid等。

- mysql 不同存储引擎区别  
	InnoDB 用于数据完整性/写性能要求比较高的应用.  热数据 活跃度比较高的 浏览量 账户资金余额 修改时间MyISAM 适合查询应用。 冷数据 用户信息 创建时间


### delete from tablea ＆ truncate table tablea的区别
>truncate 语句执行速度快,占资源少,并且只记录页删除的日志；
delete 对每条记录的删除均需要记录日志


### 说出数据连接池的工作机制是什么？
>J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。  
客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。  
如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。  
(通过参数可以决定最大连接数是多少，服务器启动的时候建立多少连接，池中需要维持多少空闲连接等。)  
当使用的连接调用完成后，就可以将连接close，这个时候池驱动程序将此连接放回连接池并且标记为空闲，其他调用就可以使用这个连接。  

### 事务的几个特性（含义+举例说明）。
事务四大特性(简称ACID)  

- 原子性（atomicity）
	一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。
- 一致性（consistency）
	事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。
	插入数据A， 写进数据还是A，不会变成B
- 隔离性（isolation）
	一个事务的执行不能被其他事务干扰。  
	即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。  
	事务A 增加数据，事务B删除数据, 互相不影响  
- 持久性（durability）
	持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。  

### char()与varchar()的区分，什么情况下用char()？（两者区别很重要）
mysql oracle中都会有的数据类型 
	
- char   
	char的长度是固定的，比如说，你定义了char(20),即使你你插入abc，不足二十个字节，数据库也会在abc后面自动加上17个空格，以补足二十个字节；   
	char是区分中英文的，中文在char中占两个字节，而英文占一个，所以char(20)你只能存20个字母或10个汉字。   
	char适用于长度比较固定的，一般不含中文的情况  
- varchar/varchar2   
	varchar是长度不固定的，比如说，你定义了varchar(20),当你插入abc，则在数据库中只占3个字节。   
	varchar同样区分中英文，这点同char。   
	varchar2基本上等同于varchar，它是oracle自己定义的一个非工业标准varchar，不同在于，varchar2用null代替varchar的空字符串   
	varchar/varchar2适用于长度不固定的，一般不含中文的情况   
- nvarchar/nvarchar2 
	nvarchar和nvarchar2是长度不固定的，不区分中英文，其长度定义的是字符数  
	nvarchar不区分中英文，比如说：你定义了nvarchar(20),你可以存入20个英文字母/汉字或中英文组合，这个20定义的是字符数而不是字节数   
	nvarchar2基本上等同于nvarchar，不同在于nvarchar2中存的英文字母也占两个字节   
	nvarchar/nvarchar2适用于存放中文   
	
### 选择char还是选择varchar的建议 
- 适宜于char的情况： 
    - 列中的各行数据长度基本一致，长度变化不超过50字节； 
    - 数据变更频繁，数据检索的需求较少。 
    - 列的长度不会变化，修改char类型列的宽度的代价比较大。 
   	- 列中不会出现大量的NULL值。 
    - 列上不需要建立过多的索引，过多的索引对char列的数据变更影响较大。 

- 适宜于varchar的情况; 
    - 列中的各行数据的长度差异比较大。 
    - 列中数据的更新非常少，但查询非常频繁。 
    - 列中经常没有数据，为NULL值或为空值 varchar存null值不占空间
 
### 占用长度的比较：
- CHAR(size)和VARCHAR(size)的区别 
    CHAR为定长的字段，最大长度为2K字节；    VARCHAR为可变长的字段，最大长度为4K字节； 
- CHAR(size)和NCHAR(size)的区别 
    CHAR如果存放字母数字占1个字节，存放GBK编码的汉字存放2个字节，存放UTF-8编码的汉字占用3个字节；   
    NCHAR根据所选字符集来定义存放字符的占用字节数，一般都为2个字节存放一个字符(不管字符或者汉字)   
	 
### 建过索引吗？什么情况下需要建立索引？优缺点
>大表的数据查询 常用查询列上面   
储存可能会用分区表

- 优点：
	- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 
	- 可以大大加快 数据的检索速度，这也是创建索引的最主要的原因。 
	- 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 
	- 在使用分组和排序 子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 
	- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 
- 缺点：
	1. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 
	- 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 
	- 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

### 索引的管理成本
- 存储索引的磁盘空间
- 执行数据修改操作（INSERT、UPDATE、DELETE）产生的索引维护
- 在数据处理时回需额外的回退空间。

### 索引的作用？为什么能够提高查询速度？（索引的原理）
>索引是提高数据查询最有效的方法，也是最难全面掌握的技术，因为正确的索引可能使效率提高10000倍，而无效的索引可能是浪费了数据库空间，甚至大大降低查询性能。  
索引就是通过事先排好序，从而在查找时可以应用二分查找等高效率的算法。  
一般的顺序查找，复杂度为O(n)，而二分查找复杂度为O(log2n)。当n很大时，二者的效率相差及其悬殊。  
举个例子：表中有一百万条数据，需要在其中寻找一条特定id的数据。如果顺序查找，平均需要查找50万条数据。而用二分法，至多不超过20次就能找到。二者的效率差了2.5万倍！  
  
### 子查询与连表查询的区别
>其实表链接查询和子查询的使用也是要视具体情况而定的。  
表链接查询不适合用于太多表进行链接查询，这样会严重影响速度的。  
太多表进行关联查询时，有些则可以使用子查询来代替，子查询在汇总统计方面也有很广泛的用途  

一般来说，表连接查询都可以用子查询替换，但反过来说却不一定，有的子查询不能用表连接来替换， 举个栗子：  
比如说有2张表，一个表(useinfo 学员信息)，包含字段userid(int),username(varhcar 50).    
一个表(useinfo 学员成绩表)，包含字段scoreId(int),userid(int),score(varhcar 50).  
如果要连表查询没参加考试学员的信息。  

- 用子查询： 
	select userid, username from useinfo where userid not in(select userid  from score).                          
	假设useinfo 有4条数据，scroe表有3条数据，说明有1名同学没参加考试。  
	用子查询就能查  出没参加考试人的信息。  
- 用连表查询  
	select * from userinfo ,scroe where userinfo.id<> scroe.userinfo   
	假设useinfo有4条数据，scroe表有3条数据，说明有1名同学没参加考试。  
	这时用连表查询，查出的结果为9条记录，显然不正确，这时子查询就不能被连表查询替换。  
	因为连表查询结果是总结果4*3-3（匹配的结果）=9.  