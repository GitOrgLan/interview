2016-04-06网易面试，两轮技术面，一轮hr面，车费报销

机试：

	1.java基础
		
	2.数据结构，树不同的度的节点的个数的关系
		
	3.给出一串虚拟机指令，求堆的大小
		
	4.顺时针打印矩阵
		
	5.大数相乘

技术面：
	
	1.面向对象
		
	2.多态，强制类型转换,A->B->C,A a=new B(),A b=(A)(new B())...,各种赋值和转换，还有调用方法(妈的变态!)
		多态:http://www.jb51.net/article/34413.htm

		class A {
	         public String show(D obj)...{
	                return ("A and D");
	         } 
	         public String show(A obj)...{
	                return ("A and A");
	         } 
		} 
		class B extends A{
		         public String show(B obj)...{
		                return ("B and B");
		         }
		         public String show(A obj)...{
		                return ("B and A");
		         } 
		}
		A a2 = new B();
		如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写(Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。
		可以认为
		a2={
			 public String show(D obj)...{
	                return ("A and D");
	         } 
	         public String show(B obj)...{
		                return ("B and B");
		         }
	         public String show(A obj)...{
	                return ("B and A");
	         } 
		}
		方法调用的优先级由高到低依次为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)

		引用类型的类型转换:
	   Father father = new Son();
       在这里Son 对象实例被向上转型为father了，但是请注意这个Son对象实例在内存中的本质还是Son类型的，只不过它的能力临时被消弱了而已，如果我们想变强怎么办？将其对象类型还原！
       Son son = (Son)father;
       这条语句是可行的，其实father引用仍然是Father类型的，只不过是将它的能力加强了，将其加强后转交给son引用了，Son对象实例在son的变量的引用下，恢复真身，可以使用全部功能了。
       父类强制转换成子类并不是总是成功，那么在什么情况下它会失效呢？
       当引用类型的真实身份是父类本身的类型时，强制类型转换就会产生错误。例如：
       Father father = new Father();
       Son son = (Son) father;
       这个系统会抛出ClassCastException异常信息
		
	3.sql注入攻击，js，xml注入攻击
		sql注入：
			String sql = "select * from user_table where username=' "+userName+" ' and password=' "+password+" '";
			填用户名和密码的时候写  username="1' or '1'='1"或者password="1' or '1'='1"
			最后形成的sql 语句就变成了select * from user where username=‘ 1' or ‘1’='1’ and password=‘ 1' or ‘1’='1’

		js注入：
			假设正在将以下文本输入到客户反馈表单中：<script>alert(“Boo!”)</script>此文本表示显示警告消息框的 JavaScript 脚本。
			在某人将此脚本提交到客户反馈表单后，消息 Boo! 会在将来任何人访问客户反馈网站时显示

		XML注入:
			XML通常用于存储数据，如果用户提供的数据是以XML的方式进行存储，那么对攻击者来说，注入额外的、攻击者可能不能正常控制的XML是有可能的。考虑下述XML，在这个XML中，攻击者仅仅能够控制Attacker Text文本：
			<?xml version="1.0" encoding="UTF-8"?>
			<USER role="guest">Attacker Text</USER>
			如果用你的输入来替换Attacker Text，那将会是多么有趣的测试用例呢？如果开发人员不够谨慎的话，他们可能错误地允许XML注入。如果以User1</USER><USER role=“admin”>User2 作为输入的话，将会产生如下的XML（用户输入的是黑体文本部分）：
			<?xml version="1.0" encoding="UTF-8"?>
			<USER role="guest">User1</USER>
			<USER role="admin">User2</USER>
			如果应用程序读取这个文件，并且决定给每个用户分配何种访问权限的时候，User2将获得管理员权限！

	4.连表查询
		
	5.数据库索引

		1).大表的数据查询 常用查询列上面 
		储存可能会用分区表

		优点：
		•第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 
		•第二，可以大大加快 数据的检索速度，这也是创建索引的最主要的原因。 
		•第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 
		•第四，在使用分组和排序 子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 
		•第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 
		缺点：
		•第一，创建索引和维护索引要耗费时间，这种时间随着数据 量的增加而增加。 
		•第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 
		•第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

		2).索引的管理成本
		1、  存储索引的磁盘空间
		2、  执行数据修改操作（INSERT、UPDATE、DELETE）产生的索引维护
		3、  在数据处理时回需额外的回退空间。

		3).分类：
		索引按存储方法分类
			B*树索引	位图索引 	
		索引按功能分类
			唯一索引 唯一索引有两个作用，一个是数据约束，一个是数据索引，其中数据约束主要用来保证数据的完整性，唯一索引产生的索引记录中每一条记录都对应一个唯一的ROWID。
			主关键字索引
			主关键字索引产生的索引同唯一索引，只不过它是在数据库建立主关键字时系统自动建立的。
			一般索引
			一般索引不产生数据约束作用，其功能主要是对字段建立索引表，以提高数据查询速度。
		索引按索引对象分类
			单列索引（表单个字段的索引）
			多列索引（表多个字段的索引）
			函数索引（对字段进行函数运算的索引）	

		4).什么情况下应该建立索引
		表的主关键字 自动建立唯一索引	
		表的字段唯一性约束
		常用的直接条件查询的字段
		查询中排序的字段 大大提高排序速度
		查询中统计或分组统计的字段

		•在经常需要搜索的列上，可以加快搜索的速度； 
		•在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构； 
		•在经常用在连接的列上，这 些列主要是一些外键，可以加快连接的速度； 
		•在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的； 
		•在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 
		•在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。


		5).什么情况下应不建或少建索引
		表记录太少
		经常插入、删除、修改的表 维护索引的成本比较高

		6).如何快速新建大数据量表的索引
		如果一个表的记录达到100万以上的话，要对其中一个字段建索引可能要花很长的时间，甚至导致服务器数据库死机，因为在建索引的时候ORACLE要将索引字段所有的内容取出并进行全面排序，数据量大的话可能导致服务器排序内存不足而引用磁盘交换空间进行，这将严重影响服务器数据库的工作。
		解决方法是增大数据库启动初始化中的排序内存参数，如果要进行大量的索引修改可以设置10M以上的排序内存（ORACLE缺省大小为64K），在索引建立完成后应将参数修改回来，因为在实际OLTP数据库应用中一般不会用到这么大的排序内存。
			
		7）.索引的作用？为什么能够提高查询速度？（索引的原理）
		索引是提高数据查询最有效的方法，也是最难全面掌握的技术，因为正确的索引可能使效率提高10000倍，而无效的索引可能是浪费了数据库空间，甚至大大降低查询性能。
		索引就是通过事先排好序，从而在查找时可以应用二分查找等高效率的算法。
		一般的顺序查找，复杂度为O(n)，而二分查找复杂度为O(log2n)。当n很大时，二者的效率相差及其悬殊。
		
	6.filter,listener,servlet区别
		1).Filter
		实现javax.servlet.Filter接口，在web.xml中配置与标签指定使用哪个Filter实现类过滤哪些URL链接。只在web启动时进行初始化操作。filter 流程是线性的， url传来之后，检查之后，可保持原来的流程继续向下执行，被下一个filter, servlet接收等，而servlet 处理之后，不会继续向下传递。filter功能可用来保持流程继续按照原来的方式进行下去，或者主导流程，而servlet的功能主要用来主导流程。
		特点：可以在响应之前修改Request和Response的头部，只能转发请求，不能直接发出响应。filter可用来进行字符编码的过滤，检测用户是否登陆的过滤，禁止页面缓存等

		2).Servlet
		servlet 流程是短的，url传来之后，就对其进行处理，之后返回或转向到某一自己指定的页面。它主要用来在业务处理之前进行控制。

		3).Listener
		servlet,filter都是针对url之类的，而listener是针对对象的操作的，如session的创建，session.setAttribute的发生，在这样的事件发生时做一些事情。
		
	7.filter时序图,流程,servlet处理完之后filter还能否继续修改request和response的内容

		Servlet过滤器能够在Servlet被调用之前检查Request对象，修改Request Header和Request内容。
		Servlet被调用之后检查Response对象，修改Response Header和Response内容。Servlet过滤器负责过滤的Web组件可以是Servlet,JSP和HTML。
		Servler过滤器实现了javax.Servlet.Filter的接口；
  		init(Filter Config)Servlet过滤器的初始化方法，Servlet过滤器实例后将调用这个方法，在这个方法中可以读取web.xml 文件中Servlet过滤器的初始化参数。
 		destory():Servlet容器在销毁过滤器的实例前调用该方法，在这个方法中可以释放Servlet过滤器占用的资源。
 		doFilter(ServletRequest ,ServletResponse,FilterChain):完成实际的过滤。
		
	8.spring事务的传播机制和隔离级别

		spring 的事务传播行为：
		Spring在TransactionDefinition接口中规定了7种类型的事务传播行为，它们规定了事务方法和事务方法发生嵌套调用时事务如何进行传播：
	　　PROPAGATION_REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。
	　　PROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。
	　　PROPAGATION_MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常。
	　　PROPAGATION_REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。
	　　PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
	　　PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。
	　　PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。

		Spring 的隔离级别
		1、Serializable：最严格的级别，事务串行执行，资源消耗最大；
		2、REPEATABLE READ：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了”脏读取”和”不可重复读取”的情况，但是带来了更多的性能损失。
		3、READ COMMITTED:大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了”脏读取”。该级别适用于大多数系统。
		4、Read Uncommitted：保证了读取过程中不会读取到非法数据。
		
	9.判断链表有环(链表特别长？能否两个指针分别走一步和三步？)

		给定一个单链表，只给出头指针h：
		1、如何判断是否存在环？
		2、如何知道环的长度？
		3、如何找出环的连接点在哪里？
		4、带环链表的长度是多少？
		 
		解法：
		1、对于问题1，使用追赶的方法，设定两个指针slow、fast，从头指针开始，每次分别前进1步、2步。如存在环，则两者相遇；如不存在环，fast遇到NULL退出。
		2、对于问题2，记录下问题1的碰撞点p，slow、fast从该点开始，再次碰撞所走过的操作数就是环的长度s。
		3、问题3：有定理：碰撞点p到连接点的距离=头指针到连接点的距离，因此，分别从碰撞点、头指针开始走，相遇的那个点就是连接点。(证明在后面附注)
		4、问题3中已经求出连接点距离头指针的长度，加上问题2中求出的环的长度，二者之和就是带环单链表的长度
		
	10.aop/ioc

		1)aop
			1、解释AOP
			面向切面的编程，或AOP， 是一种编程技术，允许程序模块化横向切割关注点，或横切典型的责任划分，如日志和事务管理。

			2、Aspect 切面	AOP核心就是切面，它将多个类的通用行为封装成可重用的模块，该模块含有一组API提供横切功能。比如，一个日志模块可以被称作日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。

			3、在Spring AOP 中，关注点和横切关注的区别是什么？
			关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。	横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。

			4、连接点
			连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个AOP切面，它实际上是个应用程序执行Spring AOP的位置。

			5、通知
			通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段。
			Spring切面可以应用五种类型的通知：
			before：前置通知，在一个方法执行前被调用。
			after: 在方法执行之后调用的通知，无论方法执行是否成功。
			after-returning: 仅当方法成功完成后执行的通知。
			after-throwing: 在方法抛出异常退出时执行的通知。
			around: 在方法执行之前和之后调用的通知。

			6、切点
			切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。

			7、什么是引入? 
			引入允许我们在已存在的类中增加新的方法和属性。

			8、什么是目标对象? 
			被一个或者多个切面所通知的对象。它通常是一个代理对象。也指被通知（advised）对象。

			9、什么是代理?
			代理是通知目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。
		2)ioc
			1、什么是Spring IOC 容器？
			Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。

			2、IOC的优点是什么？
			IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。
			
	11.hashMap和hashtable
		
	12.hashtable和currentHashMap
		
	13.ArrayList和LinkedList
		
	14.hashMap内部实现
		
	15.用栈实现队列
		
	16.gc
		
	17.序列化
		http://www.2cto.com/kf/201405/305380.html
		
	18.session和cookie
		
	19.start和run
		
	20.设计模式，单例模式，工厂模式
		
	21.进程和线程
	
	22.301和302的区别？

		302重定向是暂时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。
		301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。
	
	23.转发和重定向
	
	24.mvc是什么？针对于每一层，你用到过哪些技术？
	
	25.mybatis和hibernate的区别

		1)Mybatis优势
			MyBatis可以进行更为细致的SQL优化，可以减少查询字段。
			MyBatis容易掌握，而Hibernate门槛较高。
		2)Hibernate优势
			Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。
			Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。
			Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。
			Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。
	
	26.jsp和servlet的区别

	27.常用加密算法

hr面：
	
	1.自我介绍
		
	2.为什么想来杭州
		
	3.对网易有什么了解
		
	4.介绍一下项目
		
	5.项目怎么分工的
		
	6.项目按照什么样的依据进行架构
		虚拟机压力测试，数据库，服务器压力测试
		
	7.你有什么想问的
	
	
现在看来，还真是容易啊