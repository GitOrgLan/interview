## OSI七层模型tcp四层模型
![OSI](https://github.com/GitOrgLan/interview/blob/master/img/network/OSI.png?raw=true)
![OSI and TCP/IP](https://github.com/GitOrgLan/interview/blob/master/img/network/OSI-TCPIP.png?raw=true)

## TCP相关
![TCP](https://github.com/GitOrgLan/interview/blob/master/img/network/TCP-lifecycle.png?raw=true)

### TCP三次握手过程
- 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
- 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
- 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手
    
### TCP四次挥手过程
- 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送
- 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号
- 服务器B关闭与客户端A的连接，发送一个FIN给客户端A
- 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1

### 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？
>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

### 为什么需要三次握手，两次不可以吗？或者四次、五次可以吗？ 
我们来分析一种特殊情况，假设客户端请求建立连接，发给服务器SYN包等待服务器确认，服务器收到确认后，如果是两次握手，假设服务器给客户端在第二次握手时发送数据，数据从服务器发出，服务器认为连接已经建立，但在发送数据的过程中数据丢失，客户端认为连接没有建立，会进行重传。假设每次发送的数据一直在丢失，客户端一直SYN，服务器就会产生多个无效连接，占用资源，这个时候服务器可能会挂掉。这个现象就是我们听过的“SYN的洪水攻击”。 
总结：第三次握手是为了防止：如果客户端迟迟没有收到服务器返回确认报文，这时会放弃连接，重新启动一条连接请求，但问题是：服务器不知道客户端没有收到，所以他会收到两个连接，浪费连接开销。如果每次都是这样，就会浪费多个连接开销。


### TCP/UDP协议
- TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接
- UDP（User Data Protocol，用户数据报协议）是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上

	小结TCP与UDP的区别：
	- 基于连接与无连接；
	- 对系统资源的要求（TCP较多，UDP少）；
	- UDP程序结构较简单；
	- 流模式与数据报模式 ；
	- TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。

### Cookie和Session
由于Http是无状态的协议，所以服务端需要记录用户的状态时，就需要通过某种机制来识别具体的用户，这种机制就是Session。服务端识别客户端，就需要Cookie的帮助了，每次HTTP请求，客户端都会发送相应的Cookie到服务端，实际上大多数应用都是通过Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会告诉客户端，需要在Cookie中记录SessionID，以后每次请求把这个ID发送到服务端，服务端就知道客户端的身份了。
如果禁用了Cookie，可以使用URL重写的技术来进
行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个类似sid = xxx这样的参数，服务端据此来识别服务器。Cookie还可以把用户输入过的用户名密码存在本地，实现自动登录。

### 交换机和路由器区别
路由器通过路由算法对数据报进行转发
交换机则是一种基于MAC地址识别，能完成封装转发数据报的设备


### DNS解析
- 检查浏览器缓存中是否有对应的映射关系，如果有，结束
- 如果没有，查看操作系统缓存中是否有映射关系
- 若前两步都没有得到结果，则把域名发送给LocalDNS服务器，让LDNS解析
- 若仍然没有命中，就到RootServer域名服务器解析
- 根域名服务器返回给LDNS一个所查询的主域名服务器gDNS
- LDNS再向GDNS请求
- gTLD服务器查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是用户注册的域名服务器，这个域名解析任务就由域名提供商的服务器来完成
- Name Server域名服务器会查询储存的域名和关系映射表，得到目标IP地址后连同一个TTL返回给LDNS
- 得到ip和TTL，LDNS会缓存这个域名和IP的对应关系，缓存时间由TTL来控制
- 解析结果返回给用户主机，根据TTL缓存，解析结束

## URL、URI和URN

URL和URN都是URI，但是URI不一定是URL或者URN

- URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源
- URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源
- URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com

## HTTP协议

### HTTP协议
[链接](http://zsxxsz.iteye.com/blog/568250)

### 基本HTTP协议流程是什么?
-  打开HTTP连接。一定要记住HTTP是一种无状态协议。正因为如此，对于每一个请求你都要建立一个新的连接。
- 初始化方法请求。这里面将包含一些类型的方法指示符用来描述调用什么方法和方法所需要的参数。
- 设置HTTP请求头。这里面包含要传送的数据类型(二进制)和数据的总长。
- 发送请求。将二进制流写到服务器。
- 读取请求。目标servlet程序将被调用并接受HTTP请求数据。servlet程序就调用所有必要的参数选择相应的方法。注意，如果这是这个客户端的第一次请求，一个服务器对象的新的实例就会被创建。
- 调用方法。方法将会被服务器端的对象调用。
- 初始化方法响应。如果调用的方法抛出一个异常，客户将接收到出错信息。否则，返回的类型(如果有)将会被发送。
- 设置HTTP响应头。在响应头中，一定会设置待发送数据的类型和长度。
- 关闭连接。

### 报文结构
Request格式：

- 请求行：用来说明请求类型,要访问的资源以及所使用的HTTP版本
- 请求头：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息
- 空行：请求头部后面的空行是必须的
- 请求数据：请求数据也叫主体，可以添加任意的其他数据

```
POST / HTTP1.1
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive

name=Professional%20Ajax&publisher=Wiley
```

Response格式：

- 状态行：由HTTP协议版本号， 状态码， 状态消息 三部分组成
- 消息报头：用来说明客户端要使用的一些附加信息
- 空行：消息报头后面的空行是必须的
- 响应正文：服务器返回给客户端的文本信息

```
HTTP/1.1 200 OK
Date: Fri, 22 May 2009 06:07:21 GMT
Content-Type: text/html; charset=UTF-8

<html>
      <head></head>
      <body>
            <!--body goes here-->
      </body>
</html>
```

### get和post的区别
get
>请求可以被缓存
请求保留在浏览器历史记录中
请求可被收藏为书签
请求不应在处理敏感数据时使用
请求长度有限制
请求只应当用于取回数据

post
>请求不会被缓存
请求不会保留在浏览器历史记录中
请求不能被收藏做书签

### HTTP状态码

状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:

- 1xx：指示信息--表示请求已接收，继续处理
- 2xx：成功--表示请求已被成功接收、理解、接受
- 3xx：重定向--要完成请求必须进行更进一步的操作
- 4xx：客户端错误--请求有语法错误或请求无法实现
- 5xx：服务器端错误--服务器未能实现合法的请求

常见状态码：

- 200 OK 客户端请求成功
- 301 Moved Permanently 永久重定向 请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
- 302 Move temporarily 临时重定向 资源只是临时被移动，客户端应继续使用原有URI
- 303 See Other 查看其它地址。与301类似，使用GET和POST请求查看
- 400 Bad Request 客户端请求有语法错误，不能被服务器所理解
- 401 Unauthorized 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
- 403 Forbidden 服务器收到请求，但是拒绝提供服务
- 404 Not Found 请求资源不存在，eg：输入了错误的URL
- 500 Internal Server Error 服务器发生不可预期的错误
- 503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常

- [HTTP状态码](http://www.runoob.com/http/http-status-codes.html)
- [HTTP状态码](http://www.runoob.com/http/http-status-codes.html)

## HTTPS
Secure Hypertext Transfer Protocol 安全超文本传输协议，是使用TLS/SSL加密的HTTP协议。HTTP采用明文传输，存在窃听，篡改的风险，而TLS/SSL协议具有身份验证，信息加密和完整性校验等功能，可以避免这些问题的发生。

### TLS/SSL原理
实现主要依赖于三种算法，对称加密，非对称加密，HASH算法
利用非对称加密实现身份验证和密钥协商，对称加密采用协商的密钥对数据进行加密，基于散列的算法验证数据的完整性。
### 握手过程
![握手过程](http://www.wxtlife.com/img/https/https_02.png)

- client hello 客户端发起请求，用明文传输版本信息，可用加密套件列表，压缩算法候选列表，随机数(客户端)等等
- server hello 服务端返回协商结果，包括选择使用的协议版本，选择的加密套件，选择的压缩算法，随机数(服务端)，随机数用于后续的密钥协商。还发送对应配置的证书链，用于身份验证。
- 证书验证 验证包括:可信性，是否吊销，是否过期，域名
- client\_key\_exchange+change\_cipher\_spec+encrypted\_handshake\_message 合法性验证通过后，客户端产生随机数字Pre-master，并用证书加密，发送给服务器，三个随机数即可得到密钥。客户端通知服务器后续的通信都采用协商的通信密钥和加密算法进行加密通信。最后结合之前所有通信参数的 hash 值与其它相关信息生成一段数据，采用协商密钥 session secret 与算法进行加密，然后发送给服务器用于数据与握手验证
- change\_\cipher\_\spec+encrypted\_\handshake\_\message 服务器用私钥解密加密的Pre-master数据，基于之前交换的两个明文随机数计算得到协商的密钥。计算之前收到信息的hash值，然后解密客户端发送的encrypted handshake message，验证数据和密钥完整性，验证完毕后，服务器同样发送change cipher spec告知客户端协商完成，服务器也结合所有的通信参数信息生成一段数据并采用协商密钥发送给客户端。
- 客户端计算所有接收信息的 hash 值，并采用协商密钥解密 encrypted\_handshake\_message，验证服务器发送的数据和密钥，验证通过则握手完成;之后通信遍使用协商的密钥

## 加密算法

### 对称加密
对称加密采用了对称密码编码技术，它的特点是文件加密和解密使用相同的密钥加密
对称加密算法使用起来简单快捷，密钥较短

缺点

- 要求提供一条安全的渠道使通讯双方在首次通讯时协商一个共同的密钥。直接的面对面协商可能是不现实而且难于实施的，所以双方可能需要借助于邮件和电话等其它相对不够安全的手段来进行协商；
- 密钥的数目难于管理。因为对于每一个合作者都需要使用不同的密钥，很难适应开放社会中大量的信息交流；
- 对称加密算法一般不能提供信息完整性的鉴别。它无法验证发送者和接受者的身份；
- 对称密钥的管理和分发工作是一件具有潜在危险的和烦琐的过程。对称加密是基于共同保守秘密来实现的，采用对称加密技术的贸易双方必须保证采用的是相同的密钥，保证彼此密钥的交换是安全可靠的，同时还要设定防止密钥泄密和更改密钥的程序。

常见的对称加密算法有DES、AES

### 非对称加密

与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。

公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。

常见的非对称加密算法有：RSA、DSA（数字签名用）

### Hash算法（摘要算法）
Hash算法特别的地方在于它是一种单向算法，用户可以通过hash算法对目标信息生成一段特定长度的唯一hash值，却不能通过这个hash值重新获得目标信息。因此Hash算法常用在不可还原的密码存储、信息完整性校验等。
常见的Hash算法有MD5、SHA

### 总结

- 对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。
- 非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。
- 解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。

### DDoS攻击通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。 
	这种攻击方式可分为以下几种：
- 通过使网络过载来干扰甚至阻断正常的网络通讯；
- 通过向服务器提交大量请求，使服务器超负荷；
- 阻断某一用户访问服务器；
- 阻断某服务与特定系统或个人的通讯。
	
### 服务器被DDOS攻击时的现象：
- 被攻击主机上有大量等待的TCP连接；
- 网络中充斥着大量的无用的数据包；
- 源地址为假 制造高流量无用数据，造成网络拥塞，使受害主机无法正常和外界通讯；
- 利用受害主机提供的传输协议上的缺陷反复高速的发出特定的服务请求，使主机无法处理所有正常请求；
- 严重时会造成系统死机。
-
# Git原理
git中，所有文件内容都保存在git仓库的objects目录中。

有这几个重要的区域
- 工作空间
- 暂存区
- 本地仓库 
- 远程仓库

每个文件都有一个sha-1来标识。git对象可分为四种类型

1. blob对象，只用来存放文件内容，没有如名称路径之类的其他信息
1. tree对象，对应着目录，tree的内容为blob对象的指针和其他子tree的指针，最顶层的tree就是一个项目的快照
1. commit对象，每一次commit都会产生一个新的对象，其中包含了指向顶层tree的指针，一个指向上一次commit对象的指针，还包含了commit的时间，作者，commit message等信息。
5. tag对象，一种特殊的commit对象