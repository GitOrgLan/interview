## OSI七层模型tcp四层模型
![OSI](https://github.com/GitOrgLan/interview/blob/master/img/network/OSI.png?raw=true)
![OSI and TCP/IP](https://github.com/GitOrgLan/interview/blob/master/img/network/OSI-TCPIP.png?raw=true)

## TCP相关

### TCP三次握手过程(http://blog.csdn.net/zhushuai1221/article/details/51008950)
- 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
- 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
- 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手
    
### TCP四次挥手过程
- 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送
- 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号
- 服务器B关闭与客户端A的连接，发送一个FIN给客户端A
- 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1

### 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？
>[链接](http://blog.csdn.net/whuslei/article/details/6667471)
这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

### 为什么要三次握手，不是两次
>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误.  
“已失效的连接请求报文段”的产生在这样一种情况下：  
client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。  
本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。  
假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。  
但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。  
例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”这就很明白了，防止了服务器端的一直等待而浪费资源  

### TCP连接为什么需要两次握手
- 建立连接实际上是一个收发两方互相确认SYN号的过程，而每次确认都需要发送数据和接收ACK，因此最少需要两次SYN发送和ACK接收，TCP把第二次SYN发送和第一次SYN的ACK回复合并。如果变为两次握手，实际上就只有一方能够确认另一方的序列号，而另一方无法知道对方的SYN号，就不知道发过来的数据包是否正确，这就成为了一个单向通信的连接。
- 如果两次握手，客户端发送了请求，服务器进行ACK，就认为建立了一次双向链接的话，那么对于如下情况就会产生问题。如果有一次请求的报文因为阻塞在了某处，在发送方已经不需要连接的时候，该报文到达了接收方，接收方回复了ACK就认为已经建立了链接，开始发送消息，但是发送方收到了ACK，会断定该ACK是无效的，这样也不会接收后续的数据报，这样就浪费了接收方的资源，而三次握手就不会产生这样的情况。


### TCP/UDP协议
- TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接
- UDP（User Data Protocol，用户数据报协议）是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上

	小结TCP与UDP的区别：
	- 基于连接与无连接；
	- 对系统资源的要求（TCP较多，UDP少）；
	- UDP程序结构较简单；
	- 流模式与数据报模式 ；
	- TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。

### Cookie和Session
由于Http是无状态的协议，所以服务端需要记录用户的状态时，就需要通过某种机制来识别具体的用户，这种机制就是Session。服务端识别客户端，就需要Cookie的帮助了，每次HTTP请求，客户端都会发送相应的Cookie到服务端，实际上大多数应用都是通过Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会告诉客户端，需要在Cookie中记录SessionID，以后每次请求把这个ID发送到服务端，服务端就知道客户端的身份了。
如果禁用了Cookie，可以使用URL重写的技术来进
行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个类似sid = xxx这样的参数，服务端据此来识别服务器。Cookie还可以把用户输入过的用户名密码存在本地，实现自动登录。

### 交换机和路由器区别
路由器通过路由算法对数据报进行转发
交换机则是一种基于MAC地址识别，能完成封装转发数据报的设备


### DNS解析
- 检查浏览器缓存中是否有对应的映射关系，如果有，结束
- 如果没有，查看操作系统缓存中是否有映射关系
- 若前两步都没有得到结果，则把域名发送给LocalDNS服务器，让LDNS解析
- 若仍然没有命中，就到RootServer域名服务器解析
- 根域名服务器返回给LDNS一个所查询的主域名服务器gDNS
- LDNS再向GDNS请求
- gTLD服务器查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是用户注册的域名服务器，这个域名解析任务就由域名提供商的服务器来完成
- Name Server域名服务器会查询储存的域名和关系映射表，得到目标IP地址后连同一个TTL返回给LDNS
- 得到ip和TTL，LDNS会缓存这个域名和IP的对应关系，缓存时间由TTL来控制
- 解析结果返回给用户主机，根据TTL缓存，解析结束

## URL、URI和URN

URL和URN都是URI，但是URI不一定是URL或者URN

- URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源
- URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源
- URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com

## HTTP协议

### HTTP协议
[链接](http://zsxxsz.iteye.com/blog/568250)

### 基本HTTP协议流程是什么?
-  打开HTTP连接。一定要记住HTTP是一种无状态协议。正因为如此，对于每一个请求你都要建立一个新的连接。
- 初始化方法请求。这里面将包含一些类型的方法指示符用来描述调用什么方法和方法所需要的参数。
- 设置HTTP请求头。这里面包含要传送的数据类型(二进制)和数据的总长。
- 发送请求。将二进制流写到服务器。
- 读取请求。目标servlet程序将被调用并接受HTTP请求数据。servlet程序就调用所有必要的参数选择相应的方法。注意，如果这是这个客户端的第一次请求，一个服务器对象的新的实例就会被创建。
- 调用方法。方法将会被服务器端的对象调用。
- 初始化方法响应。如果调用的方法抛出一个异常，客户将接收到出错信息。否则，返回的类型(如果有)将会被发送。
- 设置HTTP响应头。在响应头中，一定会设置待发送数据的类型和长度。
- 关闭连接。

### 报文结构
Request格式：

- 请求行：用来说明请求类型,要访问的资源以及所使用的HTTP版本
- 请求头：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息
- 空行：请求头部后面的空行是必须的
- 请求数据：请求数据也叫主体，可以添加任意的其他数据

```
POST / HTTP1.1
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive

name=Professional%20Ajax&publisher=Wiley
```

Response格式：

- 状态行：由HTTP协议版本号， 状态码， 状态消息 三部分组成
- 消息报头：用来说明客户端要使用的一些附加信息
- 空行：消息报头后面的空行是必须的
- 响应正文：服务器返回给客户端的文本信息

```
HTTP/1.1 200 OK
Date: Fri, 22 May 2009 06:07:21 GMT
Content-Type: text/html; charset=UTF-8

<html>
      <head></head>
      <body>
            <!--body goes here-->
      </body>
</html>
```

### get和post的区别
get
>请求可以被缓存
请求保留在浏览器历史记录中
请求可被收藏为书签
请求不应在处理敏感数据时使用
请求长度有限制
请求只应当用于取回数据

post
>请求不会被缓存
请求不会保留在浏览器历史记录中
请求不能被收藏做书签

### HTTP状态码

状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:

- 1xx：指示信息--表示请求已接收，继续处理
- 2xx：成功--表示请求已被成功接收、理解、接受
- 3xx：重定向--要完成请求必须进行更进一步的操作
- 4xx：客户端错误--请求有语法错误或请求无法实现
- 5xx：服务器端错误--服务器未能实现合法的请求

常见状态码：

- 200 OK 客户端请求成功
- 301 Moved Permanently 永久重定向 请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
- 302 Move temporarily 临时重定向 资源只是临时被移动，客户端应继续使用原有URI
- 303 See Other 查看其它地址。与301类似，使用GET和POST请求查看
- 400 Bad Request 客户端请求有语法错误，不能被服务器所理解
- 401 Unauthorized 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
- 403 Forbidden 服务器收到请求，但是拒绝提供服务
- 404 Not Found 请求资源不存在，eg：输入了错误的URL
- 500 Internal Server Error 服务器发生不可预期的错误
- 503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常

- [HTTP状态码](http://www.runoob.com/http/http-status-codes.html)
- [HTTP状态码](http://www.runoob.com/http/http-status-codes.html)

## HTTPS
Secure Hypertext Transfer Protocol 安全超文本传输协议，是使用TLS/SSL加密的HTTP协议。HTTP采用明文传输，存在窃听，篡改的风险，而TLS/SSL协议具有身份验证，信息加密和完整性校验等功能，可以避免这些问题的发生。

### TLS/SSL原理
实现主要依赖于三种算法，对称加密，非对称加密，HASH算法
利用非对称加密实现身份验证和密钥协商，对称加密采用协商的密钥对数据进行加密，基于散列的算法验证数据的完整性。
### 握手过程
![握手过程](http://www.wxtlife.com/img/https/https_02.png)

- client hello 客户端发起请求，用明文传输版本信息，可用加密套件列表，压缩算法候选列表，随机数(客户端)等等
- server hello 服务端返回协商结果，包括选择使用的协议版本，选择的加密套件，选择的压缩算法，随机数(服务端)，随机数用于后续的密钥协商。还发送对应配置的证书链，用于身份验证。
- 证书验证 验证包括:可信性，是否吊销，是否过期，域名
- client\_key\_exchange+change\_cipher\_spec+encrypted\_handshake\_message 合法性验证通过后，客户端产生随机数字Pre-master，并用证书加密，发送给服务器，三个随机数即可得到密钥。客户端通知服务器后续的通信都采用协商的通信密钥和加密算法进行加密通信。最后结合之前所有通信参数的 hash 值与其它相关信息生成一段数据，采用协商密钥 session secret 与算法进行加密，然后发送给服务器用于数据与握手验证
- change\_\cipher\_\spec+encrypted\_\handshake\_\message 服务器用私钥解密加密的Pre-master数据，基于之前交换的两个明文随机数计算得到协商的密钥。计算之前收到信息的hash值，然后解密客户端发送的encrypted handshake message，验证数据和密钥完整性，验证完毕后，服务器同样发送change cipher spec告知客户端协商完成，服务器也结合所有的通信参数信息生成一段数据并采用协商密钥发送给客户端。
- 客户端计算所有接收信息的 hash 值，并采用协商密钥解密 encrypted\_handshake\_message，验证服务器发送的数据和密钥，验证通过则握手完成;之后通信遍使用协商的密钥

## 加密算法

### 对称加密
对称加密采用了对称密码编码技术，它的特点是文件加密和解密使用相同的密钥加密
对称加密算法使用起来简单快捷，密钥较短

缺点

- 要求提供一条安全的渠道使通讯双方在首次通讯时协商一个共同的密钥。直接的面对面协商可能是不现实而且难于实施的，所以双方可能需要借助于邮件和电话等其它相对不够安全的手段来进行协商；
- 密钥的数目难于管理。因为对于每一个合作者都需要使用不同的密钥，很难适应开放社会中大量的信息交流；
- 对称加密算法一般不能提供信息完整性的鉴别。它无法验证发送者和接受者的身份；
- 对称密钥的管理和分发工作是一件具有潜在危险的和烦琐的过程。对称加密是基于共同保守秘密来实现的，采用对称加密技术的贸易双方必须保证采用的是相同的密钥，保证彼此密钥的交换是安全可靠的，同时还要设定防止密钥泄密和更改密钥的程序。

常见的对称加密算法有DES、AES

### 非对称加密

与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。

公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。

常见的非对称加密算法有：RSA、DSA（数字签名用）

### Hash算法（摘要算法）
Hash算法特别的地方在于它是一种单向算法，用户可以通过hash算法对目标信息生成一段特定长度的唯一hash值，却不能通过这个hash值重新获得目标信息。因此Hash算法常用在不可还原的密码存储、信息完整性校验等。
常见的Hash算法有MD5、SHA

### 总结

- 对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。
- 非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。
- 解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。

### DDoS攻击通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。 
	这种攻击方式可分为以下几种：
- 通过使网络过载来干扰甚至阻断正常的网络通讯；
- 通过向服务器提交大量请求，使服务器超负荷；
- 阻断某一用户访问服务器；
- 阻断某服务与特定系统或个人的通讯。
	
### 服务器被DDOS攻击时的现象：
- 被攻击主机上有大量等待的TCP连接；
- 网络中充斥着大量的无用的数据包；
- 源地址为假 制造高流量无用数据，造成网络拥塞，使受害主机无法正常和外界通讯；
- 利用受害主机提供的传输协议上的缺陷反复高速的发出特定的服务请求，使主机无法处理所有正常请求；
- 严重时会造成系统死机。
-
# Git原理
git中，所有文件内容都保存在git仓库的objects目录中。

有这几个重要的区域
- 工作空间
- 暂存区
- 本地仓库 
- 远程仓库

每个文件都有一个sha-1来标识。git对象可分为四种类型

1. blob对象，只用来存放文件内容，没有如名称路径之类的其他信息
1. tree对象，对应着目录，tree的内容为blob对象的指针和其他子tree的指针，最顶层的tree就是一个项目的快照
1. commit对象，每一次commit都会产生一个新的对象，其中包含了指向顶层tree的指针，一个指向上一次commit对象的指针，还包含了commit的时间，作者，commit message等信息。
5. tag对象，一种特殊的commit对象