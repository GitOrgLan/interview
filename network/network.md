## OSI七层模型tcp四层模型是什么样的
### OSI七层参考模型 

- 应用层:    
	直接向用户提供服务，完成用户希望在网络上完成的各种工作
- 表示层:  
	对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层
- 会话层:  
	向两个实体的表示层提供建立和使用连接的方法
- 传输层:  
	向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输
- 网络层:  
	通过路由选择算法，为报文或分组通过通信子网选择最适当的路径
- 数据链路层:  
	通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路
- 物理层  

### TCP/IP

- 应用层：用来处理特定的应用，针对不同的应用提供了不同的协议，例如进行文件传输时用到的FTP协议，发送email用到的SMTP等。
- 传输层：主要功能是提供应用程序之间的通信，这一层主要是TCP/UDP协议。
- 网络层：处理分组在网络中的活动，例如路由选择和转发等，这一层主要包括IP协议、ARP、ICMP协议等。
- 网络接口层：这是协议栈的最低层，对应OSI的物理层和数据链路层，主要完成数据帧的实际发送和接收。

## TCP相关

### TCP三次握手过程(http://blog.csdn.net/zhushuai1221/article/details/51008950)
- 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
- 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
- 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手
    
### TCP四次挥手过程
- 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送
- 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号
- 服务器B关闭与客户端A的连接，发送一个FIN给客户端A
- 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1

### 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？
>[链接](http://blog.csdn.net/whuslei/article/details/6667471)
这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

### 为什么要三次握手，不是两次
>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误.  
“已失效的连接请求报文段”的产生在这样一种情况下：  
client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。  
本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。  
假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。  
但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。  
例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”这就很明白了，防止了服务器端的一直等待而浪费资源  

### TCP连接为什么需要两次握手
- 建立连接实际上是一个收发两方互相确认SYN号的过程，而每次确认都需要发送数据和接收ACK，因此最少需要两次SYN发送和ACK接收，TCP把第二次SYN发送和第一次SYN的ACK回复合并。如果变为两次握手，实际上就只有一方能够确认另一方的序列号，而另一方无法知道对方的SYN号，就不知道发过来的数据包是否正确，这就成为了一个单向通信的连接。
- 如果两次握手，客户端发送了请求，服务器进行ACK，就认为建立了一次双向链接的话，那么对于如下情况就会产生问题。如果有一次请求的报文因为阻塞在了某处，在发送方已经不需要连接的时候，该报文到达了接收方，接收方回复了ACK就认为已经建立了链接，开始发送消息，但是发送方收到了ACK，会断定该ACK是无效的，这样也不会接收后续的数据报，这样就浪费了接收方的资源，而三次握手就不会产生这样的情况。


### TCP/UDP协议
- TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接
- UDP（User Data Protocol，用户数据报协议）是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上

	小结TCP与UDP的区别：
	- 基于连接与无连接；
	- 对系统资源的要求（TCP较多，UDP少）；
	- UDP程序结构较简单；
	- 流模式与数据报模式 ；
	- TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。

### Cookie和Session
由于Http是无状态的协议，所以服务端需要记录用户的状态时，就需要通过某种机制来识别具体的用户，这种机制就是Session。服务端识别客户端，就需要Cookie的帮助了，每次HTTP请求，客户端都会发送相应的Cookie到服务端，实际上大多数应用都是通过Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会告诉客户端，需要在Cookie中记录SessionID，以后每次请求把这个ID发送到服务端，服务端就知道客户端的身份了。
如果禁用了Cookie，可以使用URL重写的技术来进
行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个类似sid = xxx这样的参数，服务端据此来识别服务器。Cookie还可以把用户输入过的用户名密码存在本地，实现自动登录。

### 交换机和路由器区别
路由器通过路由算法对数据报进行转发
交换机则是一种基于MAC地址识别，能完成封装转发数据报的设备


### DNS解析
- 检查浏览器缓存中是否有对应的映射关系，如果有，结束
- 如果没有，查看操作系统缓存中是否有映射关系
- 若前两步都没有得到结果，则把域名发送给LocalDNS服务器，让LDNS解析
- 若仍然没有命中，就到RootServer域名服务器解析
- 根域名服务器返回给LDNS一个所查询的主域名服务器gDNS
- LDNS再向GDNS请求
- gTLD服务器查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是用户注册的域名服务器，这个域名解析任务就由域名提供商的服务器来完成
- Name Server域名服务器会查询储存的域名和关系映射表，得到目标IP地址后连同一个TTL返回给LDNS
- 得到ip和TTL，LDNS会缓存这个域名和IP的对应关系，缓存时间由TTL来控制
- 解析结果返回给用户主机，根据TTL缓存，解析结束

## HTTP协议

### HTTP协议
[链接](http://zsxxsz.iteye.com/blog/568250)

### 基本HTTP协议流程是什么?
-  打开HTTP连接。一定要记住HTTP是一种无状态协议。正因为如此，对于每一个请求你都要建立一个新的连接。
- 初始化方法请求。这里面将包含一些类型的方法指示符用来描述调用什么方法和方法所需要的参数。
- 设置HTTP请求头。这里面包含要传送的数据类型(二进制)和数据的总长。
- 发送请求。将二进制流写到服务器。
- 读取请求。目标servlet程序将被调用并接受HTTP请求数据。servlet程序就调用所有必要的参数选择相应的方法。注意，如果这是这个客户端的第一次请求，一个服务器对象的新的实例就会被创建。
- 调用方法。方法将会被服务器端的对象调用。
- 初始化方法响应。如果调用的方法抛出一个异常，客户将接收到出错信息。否则，返回的类型(如果有)将会被发送。
- 设置HTTP响应头。在响应头中，一定会设置待发送数据的类型和长度。
- 关闭连接。

### 报文结构
Request格式：
HTTP请求行 
请求头 
空行 
可选的消息体 

Response格式：
HTTP状态行 
应答头 
空行 
可选的消息体

### get和post的区别
get
>请求可以被缓存
请求保留在浏览器历史记录中
请求可被收藏为书签
请求不应在处理敏感数据时使用
请求长度有限制
请求只应当用于取回数据

post
>请求不会被缓存
请求不会保留在浏览器历史记录中
请求不能被收藏做书签

##HTTPS
Secure Hypertext Transfer Protocol 安全超文本传输协议，是使用TLS/SSL加密的HTTP协议。HTTP采用明文传输，存在窃听，篡改的风险，而TLS/SSL协议具有身份验证，信息加密和完整性校验等功能，可以避免这些问题的发生。

###TLS/SSL原理
实现主要依赖于三种算法，对称加密，非对称加密，HASH算法
利用非对称加密实现身份验证和密钥协商，对称加密采用协商的密钥对数据进行加密，基于散列的算法验证数据的完整性。
###握手过程
![握手过程](http://www.wxtlife.com/img/https/https_02.png)

- client hello 客户端发起请求，用明文传输版本信息，可用加密套件列表，压缩算法候选列表，随机数(客户端)等等
- server hello 服务端返回协商结果，包括选择使用的协议版本，选择的加密套件，选择的压缩算法，随机数(服务端)，随机数用于后续的密钥协商。还发送对应配置的证书链，用于身份验证。
- 证书验证 验证包括:可信性，是否吊销，是否过期，域名
- client\_key\_exchange+change\_cipher\_spec+encrypted\_handshake\_message 合法性验证通过后，客户端产生随机数字Pre-master，并用证书加密，发送给服务器，三个随机数即可得到密钥。客户端通知服务器后续的通信都采用协商的通信密钥和加密算法进行加密通信。最后结合之前所有通信参数的 hash 值与其它相关信息生成一段数据，采用协商密钥 session secret 与算法进行加密，然后发送给服务器用于数据与握手验证
- change\_\cipher\_\spec+encrypted\_\handshake\_\message 服务器用私钥解密加密的Pre-master数据，基于之前交换的两个明文随机数计算得到协商的密钥。计算之前收到信息的hash值，然后解密客户端发送的encrypted handshake message，验证数据和密钥完整性，验证完毕后，服务器同样发送change cipher spec告知客户端协商完成，服务器也结合所有的通信参数信息生成一段数据并采用协商密钥发送给客户端。
- 客户端计算所有接收信息的 hash 值，并采用协商密钥解密 encrypted\_handshake\_message，验证服务器发送的数据和密钥，验证通过则握手完成;之后通信遍使用协商的密钥

### DDoS攻击通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。 
	这种攻击方式可分为以下几种：
- 通过使网络过载来干扰甚至阻断正常的网络通讯；
- 通过向服务器提交大量请求，使服务器超负荷；
- 阻断某一用户访问服务器；
- 阻断某服务与特定系统或个人的通讯。
	
### 服务器被DDOS攻击时的现象：
- 被攻击主机上有大量等待的TCP连接；
- 网络中充斥着大量的无用的数据包；
- 源地址为假 制造高流量无用数据，造成网络拥塞，使受害主机无法正常和外界通讯；
- 利用受害主机提供的传输协议上的缺陷反复高速的发出特定的服务请求，使主机无法处理所有正常请求；
- 严重时会造成系统死机。
-
#Git原理
git中，所有文件内容都保存在git仓库的objects目录中。

有这几个重要的区域
- 工作空间
- 暂存区
- 本地仓库 
- 远程仓库

每个文件都有一个sha-1来标识。git对象可分为四种类型

1. blob对象，只用来存放文件内容，没有如名称路径之类的其他信息
1. tree对象，对应着目录，tree的内容为blob对象的指针和其他子tree的指针，最顶层的tree就是一个项目的快照
1. commit对象，每一次commit都会产生一个新的对象，其中包含了指向顶层tree的指针，一个指向上一次commit对象的指针，还包含了commit的时间，作者，commit message等信息。
5. tag对象，一种特殊的commit对象